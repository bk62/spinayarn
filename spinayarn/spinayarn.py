from pathlib import Path

from pydantic import BaseModel
from langchain.llms.base import LLM
from langchain.chains.base import Chain
import networkx as nx
from tqdm.notebook import tqdm

from .data_models import InteractiveStory
from .chains import get_story_generation_chain
from .writer import write_story_json, write_story_twee3
from .prompts import story_prompt


class SpinAYarn(BaseModel):
    # Initialize with

    # Required
    story_outline: InteractiveStory
    llm: LLM

    # Optional
    # TODO - chain and prompt customizable

    # Generated

    # Story Graph
    story_graph: nx.DiGraph | None = None
    story_paths: list[list[str]] | None = None

    # langchain
    story_generation_chain: Chain | None = None

    # generated story
    generated_story: InteractiveStory | None = None

    class Config:
        # allow nx.DiGraph type
        arbitrary_types_allowed = True

    def prep_generation(self):
        # Generate all shortest paths through story
        if self.story_paths is None:
            self.walk_story_paths()
        # Get chain
        if self.story_generation_chain is None:
            self.story_generation_chain = get_story_generation_chain(self.llm)

    def walk_story_paths(self):
        self.story_graph = build_story_graph(self.story_outline)
        # TODO inefficient but handles multi generations b/c of iterator
        self.story_paths = list(get_story_paths(self.story_graph))

    def generate_story(self, force=False, **kwargs):
        self.prep_generation()

        # Already generated?
        if self.generated_story is not None:
            if not force:
                return self.generated_story

        # Generate story:
        return self._generate_story(**kwargs)

    def _generate_story(self, **kwargs):
        self.generated_story = self.story_outline.generate_copy()
        # TODO - path independent nodes
        # Generated text is path dependent
        # so stored by entire path as key/exported node name
        # eg. Start > Left > North ==> "Start_Left_North"

        # TODO CLI tqdm
        # Note: Convert paths into a list for better tqdm display
        for path in tqdm(list(self.story_paths), desc="building text for paths"):
            # Track the path we followed to get to each node
            path_key = []
            # Track the cumulative text generated so far, in each path
            cumulative_text = ""
            for node_name in tqdm(path, leave=False, desc=f"{'>'.join(path)}"):
                # Path -> path keys
                # e.g. "start__A__B" etc
                parent_key = "__".join(path_key)
                path_key.append(node_name)
                # Node path -> node key
                # E.g. "start__A__B__C" , if in node C etc
                node_key = "__".join(path_key)
                # Note: starting node has to be named start! TODO
                if node_name != "start":
                    # Add text generated by the parent to the cumulative text
                    # TODO add after generation instead?
                    # might not work b/c when continuing from a pre-generated node
                    cumulative_text += self.generated_story.get_node(parent_key).text
                # Check if this specific node's text is already generated
                if node_key not in self.generated_story.nodes:
                    outline_node = self.story_outline.get_node(node_name)
                    # Generate node text
                    generated_text = self.story_generation_chain.run(
                        story_so_far=cumulative_text,
                        setting=self.story_outline.setting,
                        protagonist="TODO",  # story.protagonist,
                        additional_instructions="",  # TODO
                        plot=outline_node.plot,
                        # num_lines=2,  # TODO
                    )
                    # Build generated story node corresponding to outline node
                    # with new path dependent node name
                    generated_node = self.generated_story.build_generated_node(
                        outline_node, generated_text, node_key
                    )
                    # TODO DEBUG
                    # Save prompt used to generate text as well
                    generated_node.prompt = story_prompt.format(
                        story_so_far=cumulative_text,
                        setting=self.story_outline.setting,
                        protagonist="TODO",  # story.protagonist,
                        additional_instructions="",  # TODO
                        plot=outline_node.plot,
                        num_lines=2,  # TODO variable error, ^^ mismatch
                    )

        return self.generated_story


def generate_story_from_outline(outline_yaml, llm):
    print("[+] parsing story yaml file...")
    story = InteractiveStory.from_outline_yaml(outline_yaml)
    spinayarn = SpinAYarn(llm=llm, story_outline=story)

    print("[+] generating all shortest paths through story...")
    spinayarn.prep_generation()

    print("[+] cumulatively generating story text for each node in each path...")
    generated_story = spinayarn.generate_story()

    # EXPORT:
    print("[+] Exporting generated story")
    filepath = Path(outline_yaml)
    spec_dir = filepath.parent
    filename = filepath.stem
    # save story as json
    json_fp = write_story_json(generated_story, spec_dir / f"{filename}.json")
    print("[+] wrote story to JSON file:", json_fp)
    # export story as twee file
    twee_fp = write_story_twee3(generated_story, spec_dir / f"{filename}.twee")
    print("[+] wrote story to Twee3 file:", twee_fp)
    # run tweego shell to generate html
    # generate_twine_html(twee_file)


def build_story_graph(story: InteractiveStory):
    nodes = (node for node in story.nodes)
    edges = (
        # (source, dest)
        (node.name, link)
        for node in story.nodes.values()
        for link in node.links
    )
    g = nx.DiGraph()
    g.add_nodes_from(nodes)
    g.add_edges_from(edges)
    return g


def get_story_paths(story_graph: nx.DiGraph):
    for node in story_graph.nodes():
        if node == "start":
            continue
        yield from nx.all_simple_paths(story_graph, "start", node)
